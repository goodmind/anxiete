# Anxiete

Список экзистенциальных проблем процесса разработки ПО и попытка найти их решение

## Противоречие "динамика" vs "статика", "надежность" vs "удобство"

### Проблема
Изначально никакой статики и динамики конечно нету, а есть только "спецификации" или "контракты" или "типы" или "инварианты" - ограничения на поведение работы программы которые справедливы для того или иного участка программы(функции, переменной, модуля итд).
Пример ограничения - функция возвращает список уникальных элементов, каждый элемент имеет тип `Number`
Но появляется два способа проверять подобные ограничения

#### Статически - по исходному коду без его выполнения
Cейчас это называют статическими типами. 
Плюсы:
 - надежно как швейцарские часы - если тайпчекер сказал что все в ок то программа гарантированно не содержит нежелательного поведения - например функция `add(a: number, b: number): number` никогда не вернет строку вместо числа
 - быстро - можно проверить даже очень большой проект за приемлимое время(меньше получаса)

Минусы:
 - по умолчанию считают, что ваш код не соотвествует спецификации и заставляют писать много дополнительного кода для того, чтобы доказать, что код все-таки ей соответствует
 - сложные инварианты(вроде того что функция `sort` идемподентна) не выражаются вне мозговзывательных систем типов вроде refinement и dependant типов

#### Динамически - во время исполнения
Сейчас это называют контрактами или спеками.
Плюсы:
 - по умолчанию считается, что наш код работает согласно спецификации - нет необходимости в написании какого-либо специального кода для доказательства корректности нашего кода
 - можно легко выразить любые динамические инварианты вроде идемподентности итд.

Минусы:
 - дают только вероятностные гарантии
 - чтобы хоть как то их проверить нужно либо иметь много тестов либо генерировать эти тесты из самих контрактов(при помощи инструментов property-based testing) - в любом случае прогон такого количества тестов для большого проекта это будет очень-очень медленно

### Как решать?

Нужен единый способ описания спецификаций - не привязанный к способу проверки(динамически или статически) - это может быть специальная DSL или просто библиотека для языка. Затем мы просто должны мочь выбрать как проверять те или иные спецификации - статически или динамически.
То что можем легко и безболезнено проверить статически проверяем статически - то что не можем проверяем динамически при помощи property-based testing.
Так же можно будет управлять степенью строгости проверок и их количеством в процессе разработки программы: в зависимости от того, что важнее для нас на данном этапе разработки – корректность или скорость и удобство разработки.

### Ссылки
 - http://blog.csssr.ru/2017/04/25/property-testing/ - введение в property-based testing и постановка вопроса
 - https://github.com/pelotom/runtypes, https://github.com/gcanti/tcomb, https://github.com/andreypopp/validated - либы для JS для динамической валидации но с частичной поддержкой статических типов.

### Что дальше?
 - написать генератор данных для одной из либ из списка выше
 - написать язык с встроенной поддержкой подобной системой спецификаций
 - написать самостоятельный DSL для спецификаций чтобы можно было юзать в штках типо swagger для связи с АПИ


## Отсуствие в мейнстриме first-class control-flow

### Проблема
Такие проблемы написания кода как:
 - обработка ошибок
 - асинхронность и событийность
 - сайд-эффекты
 - проверка на нулл

Сводятся к проблеме отсутсвие first-class control-flow в большинстве языков.

Control-flow - порядок выполнения (порядок исполнения, порядок вычислений) — это способ упорядочения инструкций программы в процессе её выполнения.

Примеры:

 - последовательный 
```javascript
var res1 = doSmth1(start);
var res2 = doSmth2(res1);
var res3 = doSmth3(res2);
```

 - при обработке ошибок
```javascript
var res1 = doSmth1(start);
if (res1.isError()) {
    var res2 = doSmth2(res1);
    if (res2.isError()) {
        var res3 = doSmth2(res2);
    }
}
```

 - асинхронный
```javascript
doSmth1(res1 => {
    doSmth2(res1, res2 => {
        doSmth3(res2);
    });
});
```

 - с исполнением сайд-эффектов
```javascript
var ioAction1 = doSmth1(start, IO);
ioAction.after(res1 => {
    var ioAction2 = doSmth2(res1);
    ioAction2.after(res2 => {
        doSmth3(res2);
    });
});
```

Стандартная единица абстракции кода - функция - не имеет доступа к управлению порядком управления программы. Она не может вернуть контроль исполнения, а потом его забрать обратно или произвольно переключать его.

Когда то давно когда компьютеры были большие был такой оператор goto(представим что он есть в JS и покажем как он помогает при обработке ошибок):
```javascript
var exitIfErr = res => res.isError ? goto exit : res;
var res1 = exitIfErr(doSmth1(start));
var res2 = exitIfErr(doSmth2(res1));
var res3 = exitIfErr(doSmth3(res1));
label exit;
```

Таким образом goto дает нам возможность абстрагировать произвольный control-flow. Однако широко известны проблемы [goto](https://ru.wikipedia.org/wiki/Goto#.D0.9A.D1.80.D0.B8.D1.82.D0.B8.D0.BA.D0.B0) - они делают его использование не возможным. Однако нам всетаки нужны способы абстракции control-flow.

### Как решать?
Существуют минимум 3 способа:
 
 - монады
 - обмен сообщениями
 - [продолжения](http://beautifulracket.com/explainer/continuations.html) или корутины(разделить?)

А уже при помощи них можно решать более частные задачи. И на текущий момент мы так и делаем:
 - Promise,Future - решение вопроса асинхронности при помощи монад
 - Exception - решение вопроса обработки ошибок при помощи продолжений
 - Cycle.js - решение вопроса сайд-эффектов при помощи обмена сообщениями
 - Redux-saga - решение вопроса сайд-эффектов при помощи обмена корутин
 - [Algebraic Effects](https://esdiscuss.org/topic/one-shot-delimited-continuations-with-effect-handlers) - решение вопроса сайд-эффектов при помощи обмена продолжений

Однако все это очень не генерализированно и вообще нет понимания что это все одна и та же проблема(ОРЛИ?) и вообще все эти способы ее решать так или иначе изоморфны друг другу(ОРЛИ?).


### Ссылки
 - http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
 - https://blog.jle.im/entry/first-class-statements.html
 - https://github.com/typeetfunc/csssr.github.io/blob/feature/effects/_posts/2016-12-16-side-effects-1.md - на примере сайд-эффектов чем плох second-class control-flow

### Что дальше?
 - доказать что все эти проблемы стекаются к одной или опровергнуть это
 - доказать что есть 3 способа решения проблемы и они изоморфны или опровергнуть это
 - примеры

## Постановка задач не использует VCS

### Проблема

Что такое посути своей задача? Задача это _изменение_.
Как программисты работают с изменениями? Через VCS.
Как работают с изменениями в постановке? Через отдельные тикеты.
К чему это приводит?

Ко всем тем же проблема которые были у нас при разработке в до VCS эпоху:
 - не единого актуального снепшота описания всей системы(посути есть только набор слабо связанных патчей с разной историей). Чтоб составить единое представление системы нам надо осуществить мысленный процесс синтеза всех сделанных тикетов.
 - нет снепшотов на момент времени в прошлом - нельзя сделать дифф бизнесс описания системы на текущий момент с тем что было год назад(или день)
 - не видно конфликтов постановки при мерже веток с разными задачами(например в релиз)

Эти проблемы можно решить если помимо постановки задач вести отдельную версионируемую бизнесс-доку с описанием системы. Однако очевидно что никто никогда этим заниматся не будет - так как это двойной обьем работы для постановшика. Сначала ему надо будет сделать тикет а после релиза задачи перенести смысл тикета в бизнесс-докой.
 
### Как решать?

А почему бы не сделать наоброт - вести только доку а тикеты генерить из диффов этой доки?
Причем желательно эту доку хранить там же где весь код и тесты - в репе.
И тогда в ПР у нас был бы виден дифф:
 - постановки(что хотели сделать)
 - тестов(зафиксированные правки)
 - кода(как мы добились этих правок - то есть что таки сделали)

### Что дальше?
Возникает много проблем и вопросов:
 - BDD достаточное решение(скорее нет чем да - неверю что вообще здесь хватит искуственного языка(геркина точно не хватит), и то что прям на все всегда будут написаны тесты я тоже не верю)
 - как быть с one-time тасками
 - нужна возможность как то аннотировать изменения(доп комменты писать, аттрибуты ставить итд)  - это нужно к примеру для багов
 - нужен более умный чем стандартый гитовый дифф - желательно семантический, и при этом для естественного языка. Причем желательно чтоб он понимал семантику доменной области и проекта
 - и еще вагон и маленькая тележка проблем

## Commit message это строка

## Модель данных для statefull приложений

## Противоречие выразительность vs простота

## Вики-убийца

## Декларативный рендеринг












